<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Digfender ‚Äì Or, Terre & Murs (V4 + destruction)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { margin:0; background:#0f1220; color:#e6e6f0; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #ui { position:fixed; inset:auto auto 16px 16px; background:#1a1f35; padding:12px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,.25); }
    #row1, #row2, #row3 { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { border:0; border-radius:10px; padding:8px 10px; background:#2b3568; color:#fff; cursor:pointer; white-space:nowrap; }
    button.active { background:#5660ad; }
    button[disabled] { opacity:.5; cursor:not-allowed; }
    .tower-btn { display:flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    #stats { margin-top:8px; font-size:14px; opacity:.9; white-space:pre; }
    #upgradeBtn { position:absolute; display:none; background:#3c5a2a; padding:6px 10px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,.3); }
    /* Nouveau bouton pour d√©truire une tour */
    #destroyBtn { position:absolute; display:none; background:#7a1f1f; color:#fff; padding:6px 10px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,.3); }
    canvas { display:block; margin:0 auto; image-rendering: pixelated; }

    /* --- Arbre de comp√©tences --- */
    #skillBtn { background:#24527a; }
    #skillModal { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:10; }
    #skillPanel { width:min(900px, 92vw); background:#161a2e; border-radius:14px; padding:16px 16px 24px; box-shadow:0 20px 60px rgba(0,0,0,.45); }
    #skillHeader { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
    #skillHeader h2 { margin:0; font-size:20px; }
    #tokenBadge { background:#2b3568; padding:6px 10px; border-radius:999px; }
    #skillGrid { display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; margin-top:10px; }
    .skill-col { display:flex; flex-direction:column; gap:10px; }
    .skill-node { position:relative; border-radius:10px; padding:10px; background:#1e2545; min-height:70px; display:flex; align-items:center; justify-content:center; text-align:center; font-size:14px; border:1px solid rgba(255,255,255,.06); }
    .skill-node.locked { opacity:.5; }
    .skill-node.available { outline:2px solid #66bb6a; cursor:pointer; }
    .skill-node.unlocked { background:#274463; border-color:#66bb6a; box-shadow:inset 0 0 0 2px rgba(102,187,106,.35); }
    .branch-title{ font-size:12px; opacity:.7; text-align:center; margin:6px 0 -4px; }
    .skill-help { font-size:12px; opacity:.7; margin-top:6px; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="row1">
      <button id="dig" class="active">‚õèÔ∏è Creuser / D√©truire (Roche: -5 or ‚Üí +10 terre ¬∑ Mur: -5 or ‚Üí +5 terre)</button>
      <button id="wall">üß± Mur (25 terre)</button>
      <button id="start">‚ñ∂Ô∏è Vague</button>
      <button id="skillBtn">üåø Arbre de comp√©tences</button>
    </div>
    <div id="row2" style="margin-top:8px">
      <button id="tower-basic" class="tower-btn"><span class="dot" style="background:#ffffff"></span>Tour basique</button>
      <button id="tower-yellow" class="tower-btn"><span class="dot" style="background:#ffd54f"></span>Tour √©lectrique</button>
      <button id="tower-red" class="tower-btn"><span class="dot" style="background:#ef5350"></span>Tour de feu</button>
      <button id="tower-blue" class="tower-btn"><span class="dot" style="background:#64b5f6"></span>Tour de glace</button>
      <button id="tower-brown" class="tower-btn"><span class="dot" style="background:#8d6e63"></span>Tour de terre</button>
      <button id="tower-green" class="tower-btn"><span class="dot" style="background:#66bb6a"></span>Tour herbe</button>
    </div>
    <div id="row3" style="margin-top:6px; font-size:12px; opacity:.85"></div>
    <div id="stats"></div>
  </div>

  <div id="skillModal">
    <div id="skillPanel">
      <div id="skillHeader">
        <h2>Arbre de comp√©tences</h2>
        <div id="tokenBadge">üî¨ Jetons: <span id="tokenCount">0</span></div>
      </div>
      <div class="skill-help">Jetons gagn√©s: 1er √† la vague 3, 2e √† la vague 5, puis √† 10, 15, 20, 25, ...</div>
      <div id="skillGrid">
        <!-- Colonnes par branche: Basique | Jaune | Rouge | Bleu | Marron -->
        <div class="skill-col" id="col-basic">
          <div class="branch-title">Branche Basique</div>
          <div class="skill-node" data-node="basic1">1. Tour normale</div>
          <div class="skill-node" data-node="basic2">2. Am√©lioration tour normale (max 5)</div>
          <div class="skill-node" data-node="basic3">3. Am√©lio. tour normale (max 10)</div>
          <div class="skill-node" data-node="basic4">4. (√† venir)</div>
          <div class="skill-node" data-node="basic5">5. (√† venir)</div>
        </div>
        <div class="skill-col" id="col-yellow">
          <div class="branch-title">Branche Jaune</div>
          <div class="skill-node" data-node="yellow1">3. D√©bloque tour jaune</div>
          <div class="skill-node" data-node="yellow2">4. Am√©lioration jaune (max 5)</div>
          <div class="skill-node" data-node="yellow3">5. (√† venir)</div>
          <div class="skill-node locked">‚Äî</div>
          <div class="skill-node locked">‚Äî</div>
        </div>
        <div class="skill-col" id="col-red">
          <div class="branch-title">Branche Rouge</div>
          <div class="skill-node" data-node="red1">3. D√©bloque tour rouge</div>
          <div class="skill-node" data-node="red2">4. Am√©lioration rouge (max 5)</div>
          <div class="skill-node" data-node="red3">5. (√† venir)</div>
          <div class="skill-node locked">‚Äî</div>
          <div class="skill-node locked">‚Äî</div>
        </div>
        <div class="skill-col" id="col-blue">
          <div class="branch-title">Branche Bleue</div>
          <div class="skill-node" data-node="blue1">3. D√©bloque tour bleue</div>
          <div class="skill-node" data-node="blue2">4. Am√©lioration bleue (max 5)</div>
          <div class="skill-node" data-node="blue3">5. (√† venir)</div>
          <div class="skill-node locked">‚Äî</div>
          <div class="skill-node locked">‚Äî</div>
        </div>
        <div class="skill-col" id="col-brown">
          <div class="branch-title">Branche Marron</div>
          <div class="skill-node" data-node="brown1">3. D√©bloque tour marron</div>
          <div class="skill-node" data-node="brown2">4. Am√©lioration marron (max 5)</div>
          <div class="skill-node" data-node="brown3">5. (√† venir)</div>
          <div class="skill-node locked">‚Äî</div>
          <div class="skill-node locked">‚Äî</div>
        </div>
      </div>
      <div style="display:flex; justify-content:flex-end; margin-top:14px;"><button id="closeSkill">Fermer</button></div>
    </div>
  </div>

  <button id="upgradeBtn"></button>
  <button id="destroyBtn"></button>
  <canvas id="c" width="960" height="576" margin-top="200px"></canvas>

  <script>
    // --- Param√®tres de la grille ---
    const TILE = 32;
    const COLS = 30;
    const ROWS = 18;
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const TILE_EMPTY = 0, TILE_ROCK = 1, TILE_WALL = 2;
    const grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(TILE_ROCK));

    const spawn = { r: 0, c: Math.floor(COLS/2) };
    const goal  = { r: ROWS-1, c: Math.floor(COLS/2) };
    for (let r=0; r<ROWS; r++) grid[r][goal.c] = TILE_EMPTY;

    let dist = [];
    function computeDistances() {
      dist = Array.from({length:ROWS}, ()=>Array(COLS).fill(Infinity));
      const q = [];
      if (grid[goal.r][goal.c] === TILE_EMPTY) {
        dist[goal.r][goal.c] = 0;
        q.push(goal);
      }
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      while (q.length) {
        const {r,c} = q.shift();
        for (const [dr,dc] of dirs) {
          const nr=r+dr, nc=c+dc;
          if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
          if (grid[nr][nc]!==TILE_EMPTY) continue;
          if (dist[nr][nc] > dist[r][c] + 1) {
            dist[nr][nc] = dist[r][c] + 1;
            q.push({r:nr,c:nc});
          }
        }
      }
    }
    computeDistances();

    // --- Ennemi ---
    class Enemy {
      constructor() {
        this.r = spawn.r; this.c = spawn.c;
        grid[this.r][this.c] = TILE_EMPTY;
        this.x = this.c*TILE + TILE/2;
        this.y = this.r*TILE + TILE/2;
        this.speed = 1.8;
        this.hp = 20 * 1.2**(wave-1);
        this.alive = true;
      }
      step() {
        if (!this.alive) return;
        if (dist[this.r][this.c] === Infinity) return;
        let best = {r:this.r, c:this.c, d:dist[this.r][this.c]};
        const opts = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dr,dc] of opts) {
          const nr=this.r+dr, nc=this.c+dc;
          if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
          if (grid[nr][nc]!==TILE_EMPTY) continue;
          const d = dist[nr][nc];
          if (d < best.d) best = {r:nr,c:nc,d};
        }
        const tx = best.c*TILE + TILE/2;
        const ty = best.r*TILE + TILE/2;
        const dx = tx - this.x, dy = ty - this.y;
        const len = Math.hypot(dx,dy) || 1;
        if (len < this.speed) {
          this.x = tx; this.y = ty; this.r = best.r; this.c = best.c;
        } else {
          this.x += this.speed*dx/len;
          this.y += this.speed*dy/len;
        }
        if (this.r===goal.r && this.c===goal.c) { baseHP -= 1; this.alive = false; }
      }
      hit(dmg){ this.hp -= dmg; if (this.hp<=0) this.alive=false; }
      draw(){
        if (!this.alive) return;
        ctx.beginPath(); ctx.arc(this.x,this.y,10,0,Math.PI*2);
        ctx.fillStyle = '#e76f51'; ctx.fill();
      }
    }

    // --- Tours ---
    const TOWER_DEFS = {
      basic:  { name:'Basique',    color:'#ffffff', speed:1.2, targets:1, range:3, damage:7 }, // moyenne en tout
      yellow: { name:'Electrique', color:'#ffd54f', speed:1.2, targets:4, range:2, damage:5 },
      red:    { name:'Feu',        color:'#ef5350', speed:2.5, targets:1, range:3, damage:5 },
      blue:   { name:'Glace',      color:'#64b5f6', speed:0.7, targets:1, range:5, damage:10 },
      brown:  { name:'Terre',      color:'#8d6e63', speed:0.3, targets:1, range:2, damage:20 },
      green:  { name:'Herbe',      color:'#66bb6a', speed:1.0, targets:1, range:3, damage:8 },
    };

    const towerCounts   = { basic:0, yellow:0, red:0, blue:0, brown:0, green:0 };
    const towerUpgrades = { basic:0, yellow:0, red:0, blue:0, brown:0, green:0 };

    // Co√ªt fixe par r√®gles
    function towerPrice(type){
      if (type==='basic') return 50;
      if (['yellow','red','blue','brown'].includes(type)) return 100;
      if (type==='green') return 100; // align√© sur tours color√©es
      return 9999;
    }

    // Prix d'upgrade selon type et niveau suivant
    function upgradePrice(tower){
      const nextLevel = tower.level + 1;
      if (tower.type==='basic'){
        const costs = {2:70, 3:100, 4:150, 5:250};
        return costs[nextLevel] ?? Infinity;
      }
      if (['yellow','red','blue','brown','green'].includes(tower.type)){
        const costs = {2:80, 3:120, 4:180, 5:300};
        return costs[nextLevel] ?? Infinity;
      }
      return Infinity;
    }

    // --- Arbre de comp√©tences (√©tats) ---
    // false = pas d√©bloqu√©, true = d√©bloqu√©
    const tech = {
      basic1:true,  // 1. Tour normale d√©j√† d√©bloqu√©e au d√©part
      basic2:false, basic3:false, basic4:false, basic5:false,
      yellow1:false, yellow2:false, yellow3:false,
      red1:false,    red2:false,    red3:false,
      blue1:false,   blue2:false,   blue3:false,
      brown1:false,  brown2:false,  brown3:false,
    };

    function isTowerUnlocked(type){
      if (type==='basic') return tech.basic1; // d√©bloqu√©e au d√©part
      if (type==='yellow') return tech.yellow1; // palier 3
      if (type==='red')    return tech.red1;
      if (type==='blue')   return tech.blue1;
      if (type==='brown')  return tech.brown1;
      if (type==='green')  return true; // herbe non dans l'arbre pour l'instant
      return true;
    }
    function maxLevelFor(type){
      if (type==='basic') {
        if (tech.basic3) return 10;
        if (tech.basic2) return 5;
        return 1; // pas d'am√©lioration sans tech
      }
      if (type==='yellow') return tech.yellow2 ? 5 : 1;
      if (type==='red')    return tech.red2    ? 5 : 1;
      if (type==='blue')   return tech.blue2   ? 5 : 1;
      if (type==='brown')  return tech.brown2  ? 5 : 1;
      if (type==='green')  return 5; // hors arbre
      return 5;
    }

    const towers = [];
    class Tower {
      constructor(r,c,def,type){
        this.type=type;
        this.r=r; this.c=c; this.def=def;
        this.x=c*TILE + TILE/2;
        this.y=r*TILE + TILE/2;
        this.level=1;
        this.cooldown=0;
        this.spentGold = towerPrice(type); // co√ªt d'achat enregistr√© pour remboursement
        this.updateStats();
      }
      updateStats(){
        this.range = this.def.range * TILE * 2 * (1 + 0.1*(this.level-1));
        this.rate = Math.max(3, Math.round(30 / (this.def.speed * (1+0.1*(this.level-1)))));
        this.damage = this.def.damage + 5*(this.level-1);
        this.targets = this.def.targets;
      }
      canUpgrade(){ return this.level < maxLevelFor(this.type); }
      upgrade(){
        if (!this.canUpgrade()) return;
        const price = upgradePrice(this);
        if (!Number.isFinite(price)) return;
        this.level++; towerUpgrades[this.type]++;
        this.spentGold += price; // historique d'investissement
        this.updateStats();
      }
      draw(){
        ctx.fillStyle=this.def.color;
        ctx.fillRect(this.c*TILE+8, this.r*TILE+8, TILE-16, TILE-16);
        ctx.fillStyle="#000"; ctx.font="bold 10px system-ui";
        ctx.fillText(this.level, this.c*TILE+TILE/2-3, this.r*TILE+TILE/2+3);
      }
      step(enemies){
        if (this.cooldown>0) { this.cooldown--; return; }
        const inRange = [];
        for (const e of enemies) {
          if (!e.alive) continue;
          const d = Math.hypot(e.x-this.x, e.y-this.y);
          if (d<=this.range) inRange.push({e, d});
        }
        inRange.sort((a,b)=>a.d-b.d);
        if (inRange.length){
          const n = Math.min(this.targets, inRange.length);
          for (let i=0;i<n;i++) bullets.push(new Bullet(this.x, this.y, inRange[i].e, this.damage));
          this.cooldown = this.rate;
        }
      }
    }

    const bullets=[];
    class Bullet{
      constructor(x,y,target,damage){ this.x=x; this.y=y; this.target=target; this.speed=6; this.damage=damage; this.alive=true; }
      step(){
        if (!this.alive || !this.target.alive) { this.alive=false; return; }
        const dx=this.target.x-this.x, dy=this.target.y-this.y;
        const len=Math.hypot(dx,dy)||1;
        this.x+=this.speed*dx/len; this.y+=this.speed*dy/len;
        if (Math.hypot(this.target.x-this.x, this.target.y-this.y)<8){
          this.target.hit(this.damage); this.alive=false;
          if (!this.target.alive) gold+=10;
        }
      }
      draw(){ ctx.fillStyle='#fff'; ctx.fillRect(this.x-2,this.y-2,4,4); }
    }

    // --- Jeu ---
    const enemies=[]; let frame=0, gold=100, dirt=0, wave=0, baseHP=10;
    let mode='dig';
    let selectedTower=null;

    // Vagues & jetons de recherche
    let spawningCount=0;       // nombre d'ennemis programm√©s pour la vague courante
    let spawnedSoFar=0;        // combien ont √©t√© cr√©√©s
    let spawnFinished=false;   // la vague a fini de g√©n√©rer
    let wavesCompleted=0;      // vagues compl√©t√©es (tous ennemis √©limin√©s)
    let researchTokens=0;      // d√©marrage √† 0, gains: 3,5 puis 10,15,20...

    const ui = {
      digBtn: document.getElementById('dig'),
      wallBtn: document.getElementById('wall'),
      startBtn: document.getElementById('start'),
      stats: document.getElementById('stats'),
      btnBasic: document.getElementById('tower-basic'),
      btnYellow: document.getElementById('tower-yellow'),
      btnRed: document.getElementById('tower-red'),
      btnBlue: document.getElementById('tower-blue'),
      btnBrown: document.getElementById('tower-brown'),
      btnGreen: document.getElementById('tower-green'),
      upgradeBtn: document.getElementById('upgradeBtn'),
      destroyBtn: document.getElementById('destroyBtn'),
      row3: document.getElementById('row3'),
      skillBtn: document.getElementById('skillBtn'),
      skillModal: document.getElementById('skillModal'),
      tokenCount: document.getElementById('tokenCount'),
      closeSkill: document.getElementById('closeSkill'),
    };

    function setMode(m){
      mode=m; selectedTower=null; ui.upgradeBtn.style.display="none"; ui.destroyBtn.style.display="none";
      ui.digBtn.classList.toggle('active', m==='dig');
      ui.wallBtn.classList.toggle('active', m==='wall');
      ui.btnBasic.classList.toggle('active', m==='tower-basic');
      ui.btnYellow.classList.toggle('active', m==='tower-yellow');
      ui.btnRed.classList.toggle('active', m==='tower-red');
      ui.btnBlue.classList.toggle('active', m==='tower-blue');
      ui.btnBrown.classList.toggle('active', m==='tower-brown');
      ui.btnGreen.classList.toggle('active', m==='tower-green');
    }
    ui.digBtn.onclick = ()=> setMode('dig');
    ui.wallBtn.onclick = ()=> setMode('wall');
    ui.btnBasic.onclick = ()=> setMode('tower-basic');
    ui.btnYellow.onclick = ()=> setMode('tower-yellow');
    ui.btnRed.onclick = ()=> setMode('tower-red');
    ui.btnBlue.onclick = ()=> setMode('tower-blue');
    ui.btnBrown.onclick = ()=> setMode('tower-brown');
    ui.btnGreen.onclick = ()=> setMode('tower-green');
    ui.startBtn.onclick = startWave;

    // --- Skill UI ---
    ui.skillBtn.onclick = ()=> { ui.skillModal.style.display='flex'; refreshSkillUI(); };
    ui.closeSkill.onclick = ()=> ui.skillModal.style.display='none';
    document.getElementById('skillGrid').addEventListener('click', (e)=>{
      const node = e.target.closest('.skill-node.available');
      if (!node) return;
      if (researchTokens<=0) return;
      const key = node.dataset.node;
      tech[key] = true;
      researchTokens--; ui.tokenCount.textContent = researchTokens;
      refreshSkillUI();
      updateTowerButtons();
    });

    function refreshSkillUI(){
      ui.tokenCount.textContent = researchTokens;
      const nodes = document.querySelectorAll('.skill-node[data-node]');
      nodes.forEach(n=>{
        const key = n.dataset.node;
        n.classList.remove('locked','available','unlocked');
        if (tech[key]) { n.classList.add('unlocked'); return; }
        // conditions de disponibilit√© par branche
        const [branch,level] = key.match(/([a-z]+)(\d+)/).slice(1);
        let available=false;
        if (branch==='basic'){
          if (level==='1') available = true; // d√©j√† d√©bloqu√©e mais garde la logique
          else if (level==='2') available = tech.basic1===true; // apr√®s basic1
          else if (level==='3') available = tech.basic2===true; // palier 3 accessible apr√®s basic2
          else available = tech.basic3===true; // placeholders li√©s √† la branche basique
        } else {
          if (level==='1') available = tech.basic2===true; // palier 3: n√©cessite basic2
          else if (level==='2') available = tech[branch+'1']===true; // palier 4: li√© √† sa branche
          else available = tech[branch+'2']===true; // palier 5 placeholder
        }
        n.classList.add(available? 'available':'locked');
      });
    }

    canvas.addEventListener('mousedown', e=>{
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const c = Math.floor(mx / TILE);
      const r = Math.floor(my / TILE);
      if (r<0||r>=ROWS||c<0||c>=COLS) return;
      if ((r===spawn.r&&c===spawn.c) || (r===goal.r&&c===goal.c)) return;

      // Clique sur une tour ?
      const found = towers.find(t=>t.r===r && t.c===c);
      if (found){
        selectedTower=found;
        // Bouton upgrade
        const price = upgradePrice(found);
        const canUp = found.canUpgrade() && Number.isFinite(price);
        if (canUp){
          ui.upgradeBtn.textContent = `Am√©liorer (${price} or)`;
          ui.upgradeBtn.style.left = (c*TILE+canvas.offsetLeft+40)+"px";
          ui.upgradeBtn.style.top  = (r*TILE+canvas.offsetTop)+"px";
          ui.upgradeBtn.style.display="block";
        } else {
          ui.upgradeBtn.style.display="none";
        }
        // Bouton d√©truire (toujours dispo)
        ui.destroyBtn.textContent = `D√©truire (+${Math.floor(found.spentGold/2)} or)`;
        ui.destroyBtn.style.left = (c*TILE+canvas.offsetLeft+40)+"px";
        ui.destroyBtn.style.top  = (r*TILE+canvas.offsetTop+40)+"px";
        ui.destroyBtn.style.display="block";
        return;
      }

      // Pas une tour: cacher les boutons contextuels
      ui.upgradeBtn.style.display="none";
      ui.destroyBtn.style.display="none";

      if (mode==='dig'){
        // D√©truire un mur: -5 or, +5 terre
        if (grid[r][c]===TILE_WALL && gold>=5){
          grid[r][c] = TILE_EMPTY; gold -= 5; dirt += 5; computeDistances();
          return;
        }
        // D√©truire une roche: -5 or, +10 terre
        if (grid[r][c]===TILE_ROCK && gold>=5){
          grid[r][c] = TILE_EMPTY; gold -= 5; dirt += 10; computeDistances();
          return;
        }
      } else if (mode==='wall'){
        // Construire un mur: 25 terre
        if (grid[r][c]===TILE_EMPTY && dirt>=25){
          grid[r][c] = TILE_WALL; dirt -= 25; computeDistances();
        }
      } else if (mode.startsWith('tower-')){
        const type = mode.split('-')[1];
        const ttype = type; // m√™me nom
        if (!isTowerUnlocked(ttype)) return; // verrouill√© par l'arbre
        if (grid[r][c]!==TILE_ROCK && grid[r][c]!==TILE_WALL) return; // poser sur roche/mur
        if (towers.some(t=>t.r===r&&t.c===c)) return;
        const price = towerPrice(ttype);
        if (gold < price) return;
        towers.push(new Tower(r,c,TOWER_DEFS[ttype], ttype));
        gold -= price; towerCounts[ttype]++;
      }
    });

    ui.upgradeBtn.onclick = ()=>{
      if (!selectedTower) return;
      const price = upgradePrice(selectedTower);
      if (!selectedTower.canUpgrade() || !Number.isFinite(price)) { ui.upgradeBtn.style.display='none'; return; }
      if (gold >= price){
        gold -= price;
        selectedTower.upgrade();
        ui.upgradeBtn.style.display="none";
        // Mettre √† jour le texte du bouton d√©truire apr√®s upgrade
        ui.destroyBtn.textContent = `D√©truire (+${Math.floor(selectedTower.spentGold/2)} or)`;
      }
    };

    // --- Destruction de tour : remboursement de 50% de l'or investi (achat + upgrades) ---
    ui.destroyBtn.onclick = ()=>{
      if (!selectedTower) return;
      const refund = Math.floor(selectedTower.spentGold/2);
      gold += refund;
      const idx = towers.indexOf(selectedTower);
      if (idx>=0) towers.splice(idx,1);
      selectedTower = null;
      ui.upgradeBtn.style.display="none";
      ui.destroyBtn.style.display="none";
    };

    function startWave(){
      wave++;
      const toSpawn = 10 + wave*2;
      spawningCount = toSpawn; spawnedSoFar=0; spawnFinished=false;
      for (let i=0;i<toSpawn;i++){
        setTimeout(()=> { enemies.push(new Enemy()); spawnedSoFar++; if (spawnedSoFar===spawningCount) spawnFinished=true; }, i*600);
      }
    }

    function maybeCompleteWave(){
      if (enemies.length===0 && spawnFinished && wave>0){
        wavesCompleted++;
        spawnFinished=false; // √©viter plusieurs comptages
        // Attribution des jetons: 3, 5, puis tous les 5 √† partir de 10
        if (wavesCompleted===3) researchTokens++;
        else if (wavesCompleted===5) researchTokens++;
        else if (wavesCompleted>=10 && wavesCompleted % 5 === 0) researchTokens++;
        refreshSkillUI();
      }
    }

    function drawGrid(){
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const t = grid[r][c];
          ctx.fillStyle =
            t===TILE_ROCK ? '#151933' :
            t===TILE_WALL ? '#5b3b2e' :
            '#222a55';
          ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
        }
      }
      ctx.fillStyle='#2a9d8f'; ctx.fillRect(spawn.c*TILE, spawn.r*TILE, TILE, TILE);
      ctx.fillStyle='#f4a261'; ctx.fillRect(goal.c*TILE, goal.r*TILE, TILE, TILE);
      ctx.strokeStyle='rgba(255,255,255,.04)'; ctx.lineWidth=1;
      for (let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*TILE,0); ctx.lineTo(x*TILE,ROWS*TILE); ctx.stroke(); }
      for (let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*TILE); ctx.lineTo(COLS*TILE,y*TILE); ctx.stroke(); }
    }

    function updateTowerButtons(){
      // Textes avec prix (fixes)
      ui.btnBasic.textContent  = `üóº Basique (${towerPrice('basic')} or)`;
      ui.btnYellow.textContent = `üóº Jaune (${towerPrice('yellow')} or)`;
      ui.btnRed.textContent    = `üóº Rouge (${towerPrice('red')} or)`;
      ui.btnBlue.textContent   = `üóº Bleue (${towerPrice('blue')} or)`;
      ui.btnBrown.textContent  = `üóº Marron (${towerPrice('brown')} or)`;
      ui.btnGreen.textContent  = `üóº Verte (${towerPrice('green')} or)`;

      // Verrous visuels selon l'arbre
      const lock = (btn, unlocked, hint)=>{ btn.disabled = !unlocked; btn.title = unlocked? '' : hint; };
      lock(ui.btnBasic,  isTowerUnlocked('basic'),  'D√©bloquez d\'abord "Tour normale" (palier 1) dans l\'arbre.');
      lock(ui.btnYellow, isTowerUnlocked('yellow'), 'D√©bloquez la branche jaune (palier 3).');
      lock(ui.btnRed,    isTowerUnlocked('red'),    'D√©bloquez la branche rouge (palier 3).');
      lock(ui.btnBlue,   isTowerUnlocked('blue'),   'D√©bloquez la branche bleue (palier 3).');
      lock(ui.btnBrown,  isTowerUnlocked('brown'),  'D√©bloquez la branche marron (palier 3).');
      // herbe libre

      // Info court
      ui.row3.textContent = `Upgrades max ‚Äî Basique: ${maxLevelFor('basic')} ‚Ä¢ Jaune: ${maxLevelFor('yellow')} ‚Ä¢ Rouge: ${maxLevelFor('red')} ‚Ä¢ Bleue: ${maxLevelFor('blue')} ‚Ä¢ Marron: ${maxLevelFor('brown')}`;
    }

    function loop(){
      frame++;
      for (const t of towers) t.step(enemies);
      for (const b of bullets) b.step();
      for (const e of enemies) e.step();
      for (let i=bullets.length-1;i>=0;i--) if (!bullets[i].alive) bullets.splice(i,1);
      for (let i=enemies.length-1;i>=0;i--) if (!enemies[i].alive) enemies.splice(i,1);

      maybeCompleteWave();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGrid();
      for (const t of towers) t.draw();
      for (const b of bullets) b.draw();
      for (const e of enemies) e.draw();

      updateTowerButtons();
      ui.stats.textContent =
        `Vague: ${wave}  |  Vagues compl√©t√©es: ${wavesCompleted}  |  Jetons: ${researchTokens}  |  Or: ${gold}  |  Terre: ${dirt}  |  Base: ${baseHP}HP  |  Ennemis: ${enemies.length}`;

      if (baseHP<=0){
        ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='#fff'; ctx.font='bold 48px system-ui';
        ctx.fillText('D√©faite !', canvas.width/2-90, canvas.height/2);
        return;
      }
      requestAnimationFrame(loop);
    }
    loop();

    // D√©marrage : basic1 d√©j√† d√©bloqu√©e, jetons √† 0
    refreshSkillUI();
    updateTowerButtons();
  </script>
</body>
</html>
